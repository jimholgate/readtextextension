"""Compress a directory, omitting platform specific autogenerated directories"""

import os
import zipfile
from datetime import datetime
import argparse

ACTION = "Build Read Text Extension"
PACKAGE = "read_text"


def zip_directory(
    folder_path: str = "",
    zip_name: str = "",
    omit_list: list = [".DS_Store", "__pycache__", "__MACOSX"],
) -> bool:
    """Zip a directory, omitting platform specific autogenerated directories"""
    if len(zip_name) == 0 or len(folder_path) == 0:
        return False
    try:
        with zipfile.ZipFile(
            zip_name, "w", zipfile.ZIP_DEFLATED, compresslevel=9
        ) as zipf:
            for root, dirs, files in os.walk(folder_path):
                # Exclude omit_list directories
                dirs[:] = [d for d in dirs if os.path.join(root, d) not in omit_list]
                for file in files:
                    file_path = os.path.join(root, file)
                    # Exclude omit_list files
                    list_dir = root.split(os.path.sep)
                    if list_dir[len(list_dir) - 1] not in omit_list:
                        zipf.write(file_path, os.path.relpath(file_path, folder_path))
        return os.path.isfile(zip_name)
    except IOError:
        pass
    return False


def main() -> None:
    """Give options for compressing a directory"""
    _default = os.path.dirname(os.path.dirname(__file__))
    parser = argparse.ArgumentParser(
        description="Compress a directory into a zip file."
    )
    parser.add_argument(
        "-d",
        "--directory",
        default=_default,
        help="The directory to compress (default: parent of the current directory)",
    )
    parser.add_argument(
        "-o",
        "--output",
        default=os.path.join(
            os.path.expanduser("~"),
            datetime.now().strftime(f"{PACKAGE}_%Y.%m.%d_%H.%M.oxt").lower(),
        ),
        help=f"The output zip file name (default: {PACKAGE}_YYYY.MM.DD_HH.MM.oxt in the user home directory)",
    )
    args = parser.parse_args()
    directory_to_compress = args.directory
    archive_output_name = args.output
    omit_patterns = [
        ".DS_Store",
        ".editorconfig",
        ".gitconfig",
        ".gitignore",
        ".vscode",
        "__pycache__",
        "__MACOSX",
    ]
    print(
        f"""
{ACTION}
{(len(ACTION)) * "="}
    
Package formats that use zip compression include epub books, open document files,
W3C Lightweight Packaging Format (LPF) and Microsoft Office files.
    
    * directory_to_compress : "{directory_to_compress}"
    * archive_output_name : "{archive_output_name}"

"""
    )

    if zip_directory(directory_to_compress, archive_output_name, omit_patterns):
        print(
            f""""{PACKAGE.replace("_", " ").capitalize()}" was archived in `{os.path.split(archive_output_name)[0]}`. """
        )


if __name__ == "__main__":
    main()

###############################################################################

# Read Text Extension
#
# Copyright And License
#
# (c) 2024 [James Holgate Vancouver, CANADA](readtextextension(a)outlook.com)
#
# THIS IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY IT UNDER THE
# TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY THE FREE SOFTWARE
# FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR(AT YOUR OPTION)ANY LATER
# VERSION.  THIS SCRIPT IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF MERCHANTABILITY OR
#  FITNESS FOR A PARTICULAR PURPOSE.SEE THE GNU GENERAL PUBLIC LICENSE FOR MORE
# DETAILS.
#
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE ALONG WITH
# THIS SOFTWARE; IF NOT, WRITE TO THE FREE SOFTWARE FOUNDATION, INC., 59 TEMPLE
# PLACE, SUITE 330, BOSTON, MA 02111-1307  USA
###############################################################################
